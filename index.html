<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Ownhands by no fianitnz</title>
  </head>
  <body>
  <h1 class="project-name">Ownhands</h1>
  <h2 class="project-tagline">Automatically exported from code.google.com/p/ownhands</h2>
  <a href="https://github.com/fianitnz/ownhands" class="btn">View on GitHub</a>
  <a href="https://github.com/fianitnz/ownhands/zipball/master" class="btn">Download .zip</a>
  <a href="https://github.com/fianitnz/ownhands/tarball/master" class="btn">Download .tar.gz</a>
<p>Многие уже писали себе «сайты» или планируют ими заняться, но при этом плохо представляют себе что же это такое - сайт. Серия постов посвящена построению с нуля учебного (а не супер-быстрого или супер-фичастого) сервера, на примере которого, постараемся разобрать разные практические вопросы из жизни разработчика. Первая, вступительная, часть публичная т.к. возможно многим будет интересно «как это всё устроено». Код на питоне, но это практически псевдокод на английском, поэтому ни у кого тут сложностей возникнуть не должно. Остальные части скорее всего будут показываться только для участников питоноблога.</p>

<p>Сайт это такой многослойный торт, напичканый самыми разными видами <s>крема</s> кода. Давайте посмотрим, что происходит, когда пользователь набирает в браузере http://example.com/ и зачем.</p>
[cut]
<p>Протокол HTTP работает поверх другого протокола - TCP, в котором никаких example.com нет, а есть 2.50.203.49, поэтому шаг 0 — используя службы DNS браузер получает <a href="http://ru.wikipedia.org/wiki/IP">IP</a>-адрес хоста. Сервер об этом ничего не знает, поэтому и никакого кода этому этапу не соответствует.</p>

<p>Теперь можно установить соединение до сервера. IP нам сообщили, а порт берётся из <a href="http://ru.wikipedia.org/wiki/Url#.D0.A1.D1.85.D0.B5.D0.BC.D1.8B_.28.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.8B.29_URL">схемы</a> или задаётся вручную. Обычно это 80. Зная адрес и порт клиент создаёт <a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BA%D0%B5%D1%82_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)">сокет</a> и открывает <a href="http://ru.wikipedia.org/wiki/TCP/IP#.D0.A2.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D0.BD.D1.8B.D0.B9_.D1.83.D1.80.D0.BE.D0.B2.D0.B5.D0.BD.D1.8C">соединение</a>, которое сервер принимает.</p>

<p>Для организации канала необходимо две стороны, два сокета. Клиент будет подключаться, а сервер находиться в состоянии ожидания:</p>
<pre><code lang='python'>
import socket  # Всё, что нам нужно для этого лежит в модуле socket.

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # параметры для создания TCP-сокета
sock.bind(("", 8000))                                     # слушать на всех адресах, на порту 8000. Чтобы создать сервер на порту ниже 1024 нужен рут.
sock.listen(1)                                            # перевести сокет в режим ожидания входящих соединений
conn, addr = sock.accept()                                # ожидать установки соединения
</code></pre>
<p>(Если любопытно, можно заходить на сервер через telnet или netcat или, собственно, браузером и смотреть что происходит)</p>

<p>Когда клиент делает <b>connect</b>, а сервер <b>accept</b> они получают объект-соединение из которго можно читать и писать. Фактически это пара <a href="http://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">FIFO</a> каналов.</p>

<p>Канал организован, теперь можно сообщить другой стороне о своих намерениях согласно <a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%82%D0%B5%D0%B2%D0%BE%D0%B9_%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB">протоколу</a> HTTP.</p>

<p>Первым делом посылается запрос: <code lang='python'>GET /some/stuff HTTP/1.1\r\n</code></p>

<p>Потом идут заголовки: <code lang='python'>Host: example.com\r\n</code></p>

<p>Запрос оканчивается пустой строкой: <code lang='python'>\r\n</code></p>

<p>Клиент своё дело сделал, дальше в игру вступает сервер. От него потребуется разобрать запрос на сегменты: собственно запрос, заголовки и тело.</p>

<pre><code lang='python'>
data = conn.recv(1024).split("\r\n")        # считываем запрос и бьём на строки
method, url, proto = data[0].split(" ", 2)  # обрабатываем первую строку

headers = {}
for pos, line in enumerate(data[1:]):  # проходим по строкам и заодно запоминаем позицию
    if not line.strip():               # пустая строка = конец заголовков, начало тела**
        break
    key, value = line.split(": ", 1)   # разбираем строку с заголовком
    headers[key.upper()] = value       # приводим ключ к "нормальному" виду чтобы обращение было регистронезависимым

# всё остальное - тело** запроса
body = "\r\n".join(data[pos+2:])
</code></pre>

<p>Имея на руках URL, адрес ресурса**, канал для ответа и остальные запчасти мы можем ответить. Ответ сервера клиенту состоит из тех же трёх частей:</p>

<pre><code lang='python'>
conn.send("HTTP/1.0 200 OK\r\n")           # мы не умеем никаких фишечек версии 1.1, поэтому будем сразу честны
conn.send("Server: OwnHands/0.1\r\n")      # Поехали заголовки...
conn.send("Content-Type: text/plain\r\n")  # разметка нам тут пока не нужна, поэтому говорим клиенту показывать всё как есть
conn.send("\r\n")                          # Кончились заголовки, всё остальное - тело ответа
conn.send("Hi there!")                     # привет мир
conn.close()                               # сбрасываем буфера, закрываем соединение
</code></pre>

<p>Устроив такое «короткое замыкание» браузеру и прогулявшись по стеку протоколов обеспечивающих транспорт, мы теперь можем разобрать саму начинку сервера. Тут уже пойдёт варенье вместо крема и мы вольны писать что угодно, не заглядывая в <a href="http://www.ietf.org/rfc/rfc1945.txt">RFC 1945</a>.</p>

<p>Сервер, в том виде, как сейчас обрабатывает всего один запрос и выходит. У такого поведения есть определённая полезность, но Настоящие Сервера так не делают. Продолжим.</p>

<p>Во время и после того, как соединение было принято, обработано и закрыто, с оригинальным сокетом ничего не произошло, он так и оставался в готовности принять новые соединения. И возможно даже уже что-то принял. Код, который будет повторяться завернём в вечный while:</p>

<pre><code lang='python'>
while True:
    conn, addr = socket.accept()
    ...  # код работы с соединением
    conn.close()
</code></pre>

<p>Каждый раз пересоздавать сокет и выставлять его в режим ожидания не надо. Более того, не получится т.к. порт будет занят предыдущим сокетом и сервер навернётся с соответствующим исключением.</p>

<p>Итого. От сервера требуется:</p>
<ol>
  <li>создать сокет (socket.socket)</li>
  <li>настроить его (bind, listen)</li>
  <li>принять соединение (accept)</li>
  <li>считать и распарсить запрос</li>
  <li><b>придумать ответ</b></li>
  <li>завернуть ответ в протокол</li>
  <li>выдать его и закрыть соединение</li>
</ol>

<p>Больше всего времени он проводит на этапе 5, и по большому счёту, это вообще не его дело, что там будет происходить. А происходить там может много чего. Например:</p>
<ul>
  <li>Тупо ответ как в примере какой-нибудь захардкоденой фигни. Малоприменимо, но в качестве упражнения сойдёт. Реальное применение - всякие empty_gif; у nginx.</li>
  <li>Отдача файла с диска. Не барское это дело. Такими вещами должны заниматься очень сильно оптимизированые сервера типа того же <a href="http://ru.wikipedia.org/wiki/Nginx">nginx</a>. Но мы всё равно попробуем, заодно разберём вопросы безопасности.</li>
  <li><a href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%BA%D1%81%D0%B8-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80#.D0.92.D0.B8.D0.B4.D1.8B_.D0.BF.D1.80.D0.BE.D0.BA.D1.81.D0.B8-.D1.81.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.BE.D0.B2">Обратное проксирование</a> (сервер сам делает запрос и передаёт результат клиенту). Тоже работа для nginx, но делается просто, поэтому возьмём всё равно.</li>
  <li>Выполнение другого скрипта (<a href="http://ru.wikipedia.org/wiki/CGI">CGI</a>). Морально устаревший метод вызова на каждый чих <a href="http://ru.wikipedia.org/wiki/Fork">подпроцесса</a>. Как-нибудь потом.</li>
  <li>Передача обработчику (в стиле modphp, asp). Конёк Apache - в сервер вкорячивается интерпретатор чего угодно, который на каждый урл запускает скрипты. Попытка починить CGI, который «починить» невозможно т.к. он предназначен для другого.</li>
  <li>Обработка запроса <a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%B5%D1%80_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9">сервером приложений</a>. Любимое дело Java серверов. Весь код 5го пункта живёт как часть сервера и запускается только один раз, всасывает всё в кэши, после чего как турбовеник только раскидывает запросы.</li>
</ul>

<p>Кроме того, можно сразу выделить несколько интересных применений протокола, помимо «сайтиков». Фактичски, сайт это <a href="http://ru.wikipedia.org/wiki/API">API</a> для употребления человеком. Есть ещё несколько классов задач, которые часто встречаются на практике:</p>
<ul>
  <li><a href="http://ru.wikipedia.org/wiki/Remote_Procedure_Call">RPC</a>, «удалённый вызов процедур». HTTP, благодаря своей минималистичности очень хорошо подходит в качестве транспорта для реализации службы доступа к удалённым объектам. Немного class-ной питонской магии и whatever.you_wish(to="do") начинает выполнятся на сервере, а может даже и сразу на нескольких.</li>
  <li><a href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%91%D1%80%D1%82%D0%BA%D0%B0_%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8">Обёртка</a> вокруг сложных протоколов. Если есть какая-нибудь хитрая библиотека, которая там как-то сложно работает, а её нужно вызывать из кучи языков и сред то, передав в адресе все необходимые параметры, сервер выполнит всю грязную работу и не надо будет переписывать библиотеку для очередного недоязычка. HTTP-клиенты обычно есть везде.</li>
  <li>Виртуальные файловые системы. Используя протокол <a href="http://ru.wikipedia.org/wiki/Webdav">WebDAV</a> (расширение HTTP) можно подключить в виде сетевого диска что угодно - базу данных, поисковый индекс, список рассылки или форум. Что-то типа кроссплатформенного <a href="http://ru.wikipedia.org/wiki/Fuse">FUSE</a>.</li>
</ul>

<p>В следующем заходе приведём код в порядок и сделаем большой задел для реализации возможностей в пункте 5.</p>
  </body>
</html>
